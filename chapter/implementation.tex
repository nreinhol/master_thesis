\section{Implementation}
\label{sec:implementation}

This section outlines the technical implementation of the blockchain-based LEM simulation
and presents parts of the developed source code. Therefore, we give a brief introduction to the applied 
software technologies and present the individual components and their containing attributes and functions.
Finally, we present the simulation process that we divided into \textit{Initial Setup} and \textit{Main Simulation Loop}. 

\subsection{Applied Technologies}
\label{sec:applied_technologies}
In this subsection we give a brief introduction 
to the applied software technologies and libraries.

\paragraph{Python}
An interpreted, object-oriented, high-level programming language with dynamic semantics. 
Additionally, it is simple and comes with an easy to learn syntax\footnote{https://www.python.org/}.
The programming language of choice, which is used to develop the 
respective components that communicate via the blockchain.

\paragraph{Web3.py}
A Python library for interacting with an Ethereum blockchain\footnote{https://github.com/ethereum/web3.py}. 
It enables the developed Python components to communicate via the blockchain.

\paragraph{Ganache}
A personal blockchain for Ethereum development\footnote{https://github.com/trufflesuite/ganache-cli}.
It simulates a full client behavior and makes developing Ethereum applications faster, easier and safer.
Ganache is provided on the one hand as a software tool with a graphical user interface (GUI) and on the other hand as command-line tool (CLI). In the develop LEM simulation the command line version of Ganache is used. 

\paragraph{Solidity}
A statically typed, contract-oriented, high-level programming language for implementing smart contracts on the Ethereum
blockchain\footnote{https://github.com/ethereum/solidity}.
It is used to implement the smart contract dealer. 

\clearpage
%--------------------------------------
\subsection{Components}
\label{sec:components_of_simulation}
We present the three main components \textit{Agent}, \textit{Smart Contract Dealer} and \textit{Off-chain Dealer} 
in this subsection and introduce their attributes and functions. 

\subsubsection{Agent}
\label{sec:agent_class}
The agents are implemented by a Python class and the naming is oriented on the proposed BTM.
As stated in section \ref{sec:concept_of_lem}, the agents represent the respective households in the BLEMS. 


\paragraph{Class Attributes:} The class attributes are presented and the associated source code is shown
in the following Listing \ref{lst:agent_class_attributes}.

\begin{lstlisting}[label=lst:agent_class_attributes, caption=Class Attributes of Agent, language=Python]
    class Agent(object):

    def __init__(self, agent_number, account_address, web3, dealer_contract):
        self._name = 'AGENT{}'.format(agent_number)
        self._account_address = account_address
        self._web3 = web3
        self._dealer_contract = dealer_contract
        self._optimization_problem = None
        self._bundle_set = None
        self._bid = None
        self._mkt_prices = None
        self._trade = None
        self._objective = None
        self._wealth = None
        self._accept_trade = None
\end{lstlisting}

The variables \verb|agent_number|, \verb|account_address|, \verb|web3| and \verb|dealer_contract| are initialized when the class is instantiated.
The variable \verb|agent_number| is used to identify the different agents.
Due to its uniqueness, the \verb|account_address| could be also used as an identifier, 
but it would be cumbersome due to the cryptic hexadecimal representation of the blockchain account addresses.
Therefore a more comprehensible name for each agent is established.
Furthermore, each agent is assigned an Ethereum blockchain account defined by the variable \verb|account_address|. It is required to submit and 
receive transactions via the blockchain.
The Python library for interacting with an Ethereum blockchain is represented by the variable \verb|web3|.
Moreover, the \verb|dealer_contract| constitues an object of the dealer's smart contract that knows all of its implemented functions.
Hence, this variable is needed to call the functions of the smart contract out of this Python class.
All other presented class attributes in the Listing are set during the simulation process.\\

Next, some of the essential functions of the class are introduced and described in detail.

\paragraph{Setter of Optimization Problem:} The agents require a function for receiving their optimization problem, which 
implementation is presented in Listing \ref{lst:lp_setter}.

\begin{lstlisting}[label=lst:lp_setter, caption=Setter of Optimization Problem, language=Python]
    @optimization_problem.setter
    def optimization_problem(self, value):
        self._optimization_problem = value
        self._objective = self._optimization_problem.solve().fun
        self._wealth = self.balance + abs(self._objective)
\end{lstlisting}

After setting the optimization problem, the class attributes \verb|objective| and \verb|wealth| are determined.
In this case, the attribute \verb|wealth| is defined exactly as in the BTM. 
The \verb|balance| constitues the cash endowment $e_{j}$ and \verb|objective| the optimal value of the agents
problem depending on the current amount of the shared resources $z_{j}(c_{j})$.
However, \verb|balance| is not a class attribute, but a class function that uses 
\verb|web3| and \verb|account_address| to retrieve the current
balance of the account from the blockchain.

\paragraph{Determination of Bundle Attributes:} The implementation of the function for solving the BDP and hence determining 
the improving bundle set and the associated bid is introduced in the Listing \ref{lst:determine_bundle}.

\begin{lstlisting}[label=lst:determine_bundle, caption=Determination of Bundle Attribute, language=Python]
    def determine_bundle_attributes(self):
        result = solve_bundle_determination(self._optimization_problem, self._mkt_prices)
        self._bundle_set = result.x
        self._bid = self._objective - result.fun
\end{lstlisting}

First, the BDP is solved in a separate function in subject to the optimization problem and the current market prices.
The associated source code of the function can be found in appendix \ref{appendix:additional_agent}.

The \verb|bundle_set| constitutes the improving bundle set and is assigned from the results of the BDP.
Further, the \verb|bid| is initialized. We stated that the BTM implemented nonstrategic bidding and pricing,
which is why an agent always submits a limit price equal to the valuation of the bundle, such that $l(w) = v(w)$.
The value of \verb|bid| is assigned by the difference of the \verb|objective| $z_{j}(c_{j})$ and the 
objective of the optimization problem with the additional resources of the \verb|bundle_set| $z_{j}(c_{j}+w)$, 
which reflects the definition of the bundles true value $v(w) = z_{j}(c_{j}) - z_{j}(c_{j}+w)$.

\paragraph{Submitting of Order:} Listing \ref{lst:set_order} presents the implementation of the function for 
submitting orders to the dealer's smart contract.
Currently, smart contracts in Ethereum do not fully 
support fixed point numbers. It is possible to declare them, but they cannot be assigned to or from \shortcite{solidity_fixed_point}.
This poses a problem because the values in the BTM often contain fixed point numbers. Therefore, 
we developed a workaround that shifts the decimal places to the right and truncates
the remainder when values sent to the dealer's smart contract so that integer values are generated.
When obtaining values from the dealer's smart contract we shift the decimal places to the left to restore 
the original fixed point values. 
Due to this, the \verb|bundle_set| and \verb|bid| are prepared for 
sending to the dealer's smart contract.

\begin{lstlisting}[float=htbp, label=lst:set_order, caption=Submitting of Order to Smart Contract Dealer, language=Python]
    def set_order(self):
        bundle_set = utils.prepare_for_sending(self._bundle_set)
        bid = utils.prepare_for_sending(self._bid)
        
        if(bid > 0):
            prepayment = utils.from_ether_to_wei(self._bid)
        else:
            prepayment = 0

        self._dealer_contract.contract.functions.setOrder(bundle_set, bid, prepayment).transact({'from': self._account_address, 'value': prepayment})
\end{lstlisting}

Additionally, it is identified if the \verb|bid| represents a buy or a sell order by examining if the value 
of \verb|bid| is greater than zero. In case of a buy order, the agents have to pay in advance, to which 
the variable \verb|prepayment| is assigned in the amount of \verb|bid|.
We implemented this procedure to prevent the strategic placing of orders and to ensure 
that the financial resources are available.
In case of a sell order, no payment in advance is required and the \verb|prepayment| is set to zero.
As stated earlier, Wei is a subdivision of the cryptographic currency of Ethereum and presents the base unit within smart contracts.
As 1 Ether is defined as $10^{18}$ Wei, we decided to specify all monetary values on the side 
of the agents and the off-chain dealer in Ether for better clarity.
Therefore, the \verb|bid| is converted from Ether to Wei before assigning to the \verb|prepayment|.
Finally, the \verb|dealer_contract| is used to call the function of the dealer's smart contract which is
responsible for setting the orders.

\paragraph{Agent Trade Verification:} Moving calculations off the blockchain comes along with the drawback that source code is not
transparent to all agents anymore. 
That comes to bear in the opacity of the trade calculation of the dealer. 
To adress this issue we implemented a trade verification procedure based on 
strong duality theory, which implementation is outlined in Listing \ref{lst:verify_trade}.
The verification procedure applies the Strong Duality Theorem to verify the validity of the off-chain dealer's calculations.
That means, if the primal MMP has an optimal solution $x^{*}$, then 
the dual also has an optimal solution $y^{*}$, such that $c^{T}x^{*} = b^{T}y^{*}$.
Due to this, it is possible to verify if the solution of the dealer is optimal, without solving the corresponding MMP. 
The agents calculate whether strong duality holds and decide on the basis of the result whether they accept the trade or not.
Because of the limitations of floating point arithmetic\footnote{https://docs.python.org/2/tutorial/floatingpoint.html}, 
we round off the values of the MMP and the dual problem to make sure that correct trades 
are not rejected based on limited machine accuracy.
Finally, the class variable \verb|accept_trade| is assigned according to the result of the trade verification 
procedure.

\begin{lstlisting}[float=htbp, label=lst:verify_trade, caption=Agent Trade Verification, language=Python]
    def verify_strong_duality(self):
        mmp_values, mmp_duals, mmp_target_coefs, mmp_bounds = self.get_mmp_attributes()
        primal_solution = (-np.sum(mmp_values * mmp_target_coefs))
        dual_solution = np.sum(mmp_duals * mmp_bounds)
        primal_solution = math.floor(primal_solution * 10) / 10
        dual_solution = math.floor(dual_solution * 10) / 10

        if primal_solution == dual_solution:
            self._accept_trade = True
        else:
            self._accept_trade = False
\end{lstlisting}


\paragraph{Notification of Trade Acceptance:} Likewise, the class contains a function for notifing the dealer's smart contract if the respective trade is accepted or not,
as shown in the Listing \ref{lst:accept_trade}.

\begin{lstlisting}[float=htbp, label=lst:accept_trade, caption=Notification of Trade Acceptance, language=Python]
    def accept_trade(self):
        if(self._accept_trade):
            trade = self._dealer_contract.contract.functions.acceptTrade(self._accept_trade).call({'from': self._account_address})
            self._trade = utils.prepare_for_storing(trade)

        self._dealer_contract.contract.functions.acceptTrade(self._accept_trade).transact({'from': self._account_address})

\end{lstlisting}

In case the trade is accepted, it is fetched and stored in the variable \verb|trade|. Since the trade 
is fetched from the dealer's smart contract, the stated workaround that shifts the decimal places follows
at this point to restore the original fixed point values.
Furthermore, an almost identical function invocation of the dealer's smart contract 
function \verb|acceptTrade()| is indicated twice. 
The difference lies in the methods \verb|call()| and \verb|transact()|. 
The \verb|call()| method enables to invoke any smart contract function on a read-only basis
and returns values sent by the smart contract return statement. 
Those read-only invocations run much faster than transactions that require network verification.
On the contrary, the \verb|transact()| method submits a verified transaction that potentially changes the state of the blockchain. 
Hence, network verification is needed that causes a significant delay due to the mining procedure.
Consequently, this method does not return the values of the smart contract return statements,
but the transaction hash of the submitted verified transaction.
Regarding the implementation, the first invocation only serves to fetch the respective trade,
whereas the second call of the function serves to notify the dealer whether the trade has been accepted or not.
For this reason, the first call of the dealer's smart contract function \verb|acceptTrade()| 
is only executed if the trade is accepted. 

\paragraph{Adding of Trade to Shared Resources:} The implementation of the function for adding the received trade to the shared resources is presented 
in Listing \ref{lst:add_trade_to_shared_resources}.

\begin{lstlisting}[float=htbp, label=lst:add_trade_to_shared_resources, caption=Adding of Trade to Shared Resources, language=Python]
    def add_trade_to_shared_resources(self):
        if(self._accept_trade):
            self._optimization_problem.shared_resources = np.add(self._optimization_problem.shared_resources, self._trade)
            self._objective = self._optimization_problem.solve().fun  
            self._wealth = self.balance + abs(self._objective)
\end{lstlisting}

The body of the function is only executed if the trade has been accepted.
First, the new allocation of the shared resources is calculated ($c_{j} \leftarrow c_{j} + w_{j}^{*}$).
Due to the new allocation of shared resources, the \verb|objective| and also the \verb|wealth| is recalculated accordingly.


\subsubsection{Smart Contract Dealer}
\label{sec:smart_contract_dealer}
The smart contract dealer is implemented by the programming language Solidity, which is the most popular and frequently 
used language for Ethereum smart contracts. In the beginning, the attributes are outlined and presented in Listing 
\ref{lst:contract_attributes}.

\begin{lstlisting}[float=htbp, label=lst:contract_attributes, caption=Attributes of Smart Contract Dealer, language=Java]
    contract Dealer{
        // general attributes
        address private _owner;
        int256[] public resource_inventory;
        int256[] public mkt_prices;

        // attributes for order management
        uint32 public order_count;
        uint32[] public order_indices;
        mapping(uint32 => Order) public orders;

        // attributes for trade management
        mapping (address => uint256) account_index; 
        address[] public trades_accounts;
        mapping(address => int256[]) public trades;
        mapping(address => uint256) public bills;
        mapping(address => uint256) public prepayments;
        mapping(address => uint256) public refunds;
\end{lstlisting}

\paragraph{Contract Attributes:} First, general attributes are declared.
We stated that the creator of a smart contract does not have any special permissions at the protocol level, but
that it is possible to specify explicitly those special permissions in the source code.  
For this reason we initialized the variable \verb|owner| with the address of the contract creator, who is, in our case,
the off-chain dealer. The \verb|owner| comes to bear in the implementation of the modifier \verb|onlyByOwner()|.
A modifier can be seen as an extension of a function and is mainly used to
check if certain conditions are met before executing the rest of the source code in the body of a function.
We have built the modifier to ensure that only the owner of the contract has the authority to perform certain functions.
In addition, attributes for managing the orders and trades of the agents are declared. 
The orders, trades and additional properties of the trades are predominantly managed in mappings.
A mapping is a collection of key-value pairs, in which all keys and all values must be of the same 
data type. However, Solidity does not provide an iteration
function to retrieve all the lists that are stored in a mapping, why it is not possible 
to read the values from the mapping without knowing the respective keys.
Therefore, we developed a workaround and store the keys of mappings in additional arrays which serves 
as look up tables.
With reference to the Listing \ref{lst:contract_attributes}, the array \verb|order_indices| functions as a 
look up table for the mapping \verb|orders|, and the array \verb|trades_accounts| for the mapping 
\verb|trades| and all other trades related mappings. \\

Next, the essential functions of the dealer's smart contract are introduced and described in detail.

\paragraph{Receiving of Orders:} The function for receiving the orders of the agents is outlined in the Listing \ref{lst:set_order_contract}.
It contains, on the one hand, the Solidity built-in modifier \verb|payable|, and on the other hand, the custom
modifier \verb|checkPrepayment|. To allow a function to receive payments, it must be declared as \verb|payable|,
otherwise the incoming payment would not be accepted and the belonging transaction would not terminate successfully.
In order to receive the prepayments of the agents, this function requires the stated modifier.
Further, we developed the second modifier \verb|checkPrepayment|, which checks whether the amount sent with the 
transaction corresponds to the amount to be paid. Thus it is verified if the transaction is a valid order.
Hence, if the prepayment is not sufficient, the function call of the agents is rejected and 
the order is not accepted.


\begin{lstlisting}[float=htbp, label=lst:set_order_contract, caption=Receiving of Orders from Agents, language=Java]
    function setOrder(int256[] _bundle, uint256 _bid, uint256 _prepayment) public payable checkPrepayment(_prepayment) {

        Order memory new_order = Order(
            msg.sender,
            _bundle,
            _bid
        );
        orders[order_count] = new_order;
        order_indices.push(order_count);

        // increment order count
        order_count ++;
    }
\end{lstlisting}

If the preconditions defined by the modifiers are fulfilled and the function body is executed, 
the variable \verb|new_order| is initialized by the object \verb|Order|. The object is implemented by the data type
struct, which is a user-defined data container for grouping variables and is well suited to bundle and 
manage all necessary information regarding the orders. The \verb|msg.sender|, \verb|bundle| and \verb|bid|
are contained in the data container and represent the essential information regarding an agents order.
When a contract is executed, it has access to a small set of global objects to which the object \verb|msg| belongs.
This object contains information regarding the transaction which invokes the contract execution,
such as the account address that can be accessed by the variable \verb|msg.sender|.
Finally, the \verb|new_order| is added to the mapping \verb|orders|, to which 
the incremental number \verb|order_count| serves as the key.
After each incoming order, the number is increased by one and added to the array \verb|oder_indices|
that serves as a look up table as mentioned earlier.

\paragraph{Receiving of Trades:} The function which serves to set the trades of the agents is introduced in Listing \ref{lst:set_trade_contract}.
With reference to the function header, the modifier \verb|onlyByOwner()| is applied, which ensures that
only the owner of the contract has the authority to call this function.
It is required, since nobody except the owner (off-chain dealer) should have 
the permission to call this function and thus to set the trades of the agents.
Then, the function \verb|addToArray()| is called, which examines whether the account, 
is already contained in the array \verb|trades_account|.
If not, the account is added to the array, which again serves as the look up table for the
mapping \verb|trades| and all other trades related mappings. 

\begin{lstlisting}[float=htbp, label=lst:set_trade_contract, caption=Receiving of Trades from Off-chain Dealer, language=Java]
    function setTrade(address _account, int256[] _trade, uint256 _prepayment, uint256 _bill, uint256 _refund) public onlyByOwner() {
        addToArray(_account);
        trades[_account] = _trade;
        bills[_account] = _bill;
        prepayments[_account] = _prepayment;
        refunds[_account] = _refund;
    }
\end{lstlisting}


In conclusion, all the required information for a trade are placed in the corresponding mappings, 
to which the account address is used as the key.

\paragraph{Interface of Trades:} The function for providing the trades of the agents is outlined and shown in Listing \ref{lst:accept_trade_contract}.
It can be seen as the interface of trades, as it enables agents 
to accept and fetch or to reject their trades.

\begin{lstlisting}[float=htbp, label=lst:accept_trade_contract, caption=Interface of Trades, language=Java]
    function acceptTrade(bool accept_trade) public returns (int256[]) {
        if(accept_trade) {
            msg.sender.transfer(refunds[msg.sender]);
            return trades[msg.sender];
        } else {
            msg.sender.transfer(prepayments[msg.sender]);
            delete trades[msg.sender];
        }
    }
\end{lstlisting}

In case of trade acceptance, the trade is returned and 
the refund is paid to the respective agent who invokes the function. 
As stated, the agents have to prepay the true value of the
requested bundle, but they often only get shares of their requested bundles due
to the solution of the MMP.
For this reason, the agents have often prepaid more than they have to pay, which leads to 
excess payments. Because of this, the dealer calculates the difference between the prepayment 
and the price of the granted trade and refunds it.
In case of trade rejection, the dealer refunds the whole prepayment and deletes the granted trade.
The deletion of a rejected trade is necessary to calculate the dealer's resource inventory correctly
after the settlement process.


\subsubsection{Off-chain Dealer}
\label{sec:off_chain_component}
The dealer is implemented by a smart contract in conjunction with 
a conventional software client. 
In contrast to the subsection in which we introduced the Smart Contract Dealer, 
this chapter introduces the part of the conventional software client called Off-chain Dealer,
implemented by a Python class.

\paragraph{Class Attributes:} The class attributes are described and the associated source code
is provided in Listing \ref{lst:offchain_class_attributes}.
Similar to the implementation of the agents, the \verb|account_address|, \verb|web3|, 
\verb|dealer_contract| are initialized by instantiation of the class and serve for 
the same purpose. Besides, the attributes \verb|shared_resource_size| and \verb|mkt_prices|
are initialized simultaneously. The \verb|shared_resource_size| constitutes the amount 
of the various shared resources $c$ and is required to determine the vector size 
of the traded bundles and related market price vector. 
The variable \verb|mkt_prices| represents the market price vector and is initialized by zeros with subject to
the \verb|shared_resource_size|. The other shown class attributes in the Listing are set during the
simulation process.

\begin{lstlisting}[float=htbp, label=lst:offchain_class_attributes, caption=Class Attributes of Off-chain Dealer, language=Python]
    class Dealer(object):

        def __init__(self, account_address, web3, dealer_contract, shared_resource_size):
            self._account_address = account_address
            self._web3 = web3
            self._dealer_contract = dealer_contract
            self._resource_inventory = None
            self._trade = None
            self._shared_resource_size = shared_resource_size
            self._mkt_prices = np.zeros(self._shared_resource_size)
            self._order_handler = None
\end{lstlisting}

Next, the essential functions of the class are introduced and explained in detail.\\

\paragraph{Fetching of Orders:} The function to retrieve the orders of the agents from the dealer's 
smart contract is introduced in the Listing \ref{lst:offchain_get_orders}.

\begin{lstlisting}[float=htbp, label=lst:offchain_get_orders, caption=Fetching of Orders from Smart Contract Dealer, language=Python]
    def get_orders(self):
        self._order_handler = utils.OrderHandler()
        order_indices = self.get_order_indices()

        # get all orders from contract and store in order handler
        for order_id in order_indices:
            order = self._dealer_contract.contract.functions.getOrder(order_id).call()
            self._order_handler.add_order(order_id, order)
\end{lstlisting}

We developed a class \verb|OrderHandler| to store and manage the orders of the agents' more easily
on the side of the off-chain dealer. 
It works like a kind of dictionary and contains the account addresses as the key 
and the corresponding trades as values, but additionally provides methods to calculate
the relevant attributes of the trades in subject to the orders.
Therefore, the variable \verb|order_handler| is initialized with an object of \verb|OrderHandler|
and the iteratively retrieved orders from the dealer's smart contract are stored in it.

Furthermore, the class also provides functions for creating and solving the MMP.
Due to the focus on the architectural design and implementation of the simulation and the high complexity
of these functions, they are not presented in detail. However, the corresponding source code can be found in appendix \ref{appendix:additional_offchain}.

\paragraph{Setting of Trades:} The function to set the trades of the agents in the dealer's smart contract 
is outlined and presented in the Listing \ref{lst:offchain_set_trades}.
The results from the MMP represent the share of the respective orders and are set for 
each order in the \verb|order_handler|. Then, the calculation of the relevant attributes of the trades
(prepayment, bill, and refund) is executed, whereby the provided methods of the \verb|OrderHandler| come to bear.

\begin{lstlisting}[float=htbp, label=lst:offchain_set_trades, caption=Setting of Trades in Smart Contract Dealer, language=Python]
    def set_trades(self):
        self.set_trade_share()
        self.initiate_trade_calculation()
        self.initiate_prepayment_calculation()
        self.initiate_bill_calculation()
        self.initiate_refund_calculation()

        for order in self._order_handler.get_all_orders():
            account, trade, prepayment, bill, refund = order.get_trade_information()
            prepayment = utils.from_ether_to_wei(prepayment)
            bill = utils.from_ether_to_wei(bill)
            refund = utils.from_ether_to_wei(refund)

            self._dealer_contract.contract.functions.setTrade(account, trade, prepayment, bill, refund).transact({'from': self._account_address})
\end{lstlisting}

In conclusion, the calculated trades and the corresponding attributes are set iteratively in the dealer's smart contract. 
Again, the monetary values like \verb|prepayment|, \verb|bill|, and \verb|refund| are converted from Ether to Wei and 
the values of the trades are converted to integer by shifting the decimal places.

\subsubsection{Blockchain}
The applied blockchain is described in this subsection. In section \ref{sec:applied_technologies}, we already
stated that we used a personal blockchain called Ganache, which acts like a personal Ethereum full client.
However, Ganache provides even more features that allow you to customize the properties of the Blockchain.
First, you can specify the number of generated accounts and the assigned amount of ether.
This is a proper way to specify the initial cash endowments of the agents ($e_{j},$ for $j=1, ..., k$)
and the dealer ($e_{0}$).
Further, it is possible to adjust the block time, which defines the time it takes to mine a new block. 
Additionally, it provides the feature to instantly mine a new block for every transaction. 
This is very useful for testing and debugging applications like the BLEMS.
Likewise, it is possible to specify the price of gas in Wei and the gas limit of a block. 
Hence, the applied blockchain Ganache allows you to recreate many scenarios of different blockchain behavior
and is therefore perfectly suited for the application of a simulation.


\subsection{Simulation Process}
This subsection presents the whole simulation process. 
In contrast to the previous subsection that 
considered the individual components in isolation, this subsection focus 
on the interaction of the various components.
Therefore, we divided the simulation process into 
\textit{Initial Setup} and \textit{Simulation Loop},
which are described in the following.

\subsubsection{Initial Setup}
The part of the initial setup and the associated source code is shown in the Listing \ref{lst:initial_setup}.
As the name suggests, all initial configurations for the simulation are performed in this part.

\begin{lstlisting}[float=htbp, label=lst:initial_setup, caption=Initial Setup of Simulation, language=Python]
    # general setup of simulation
    var = mem.Variables()
    lp.decompose(var)

    # set initial inventory and market prices
    var.dealer.set_resource_inventory()
    var.dealer.set_mkt_prices()  
\end{lstlisting}

\paragraph{Global Memory:} An object of the class \verb|Variables| is instantiated, which 
can be seen as a kind of global memory.
It contains all fundamental variables, which are required to run the simulation.
These variables are described in more detail in the following list.

\begin{description}
	\item[\texttt{central\_problem}:] Represents the specified central optimization problem of the presented BTM.
    It is divided into subproblems and distributed to the existing agents. It is important 
    to note that the number of variables present in the problem can be exactly divided by the number of agents.
    Otherwise, an exception is thrown.
	\item[\texttt{web3}:] Represents the object of the Python library, which enables the interaction with an
	Ethereum blockchain. It is the same object that is passed to the agent classes and the off-chain dealer class.
    \item[\texttt{dealer\_contract}:] Represents the object of the dealer's smart contract. 
    It is the same object that is passed to the agent classes and the off-chain dealer class. It contains all the
    implemented functions of the dealer's smart contract. When the contract is deployed and thus anchored in the blockchain, a JSON file is created. 
    This file is denoted as the \textit{Contract Application Binary Interface (ABI)}. The ABI is used to instantiate the Python object.  
    \item[\texttt{agent\_pool}:] Represents a list containing all existing agent objects. 
    Therefore all existing accounts are read from the blockchain and used to instantiate the agents.
    \item[\texttt{dealer}:] Represents the object of the off-chain dealer, which is instantiated with the 
    remaining account.
\end{description}

\paragraph{Decomposition of Central Problem:} Next, the function for decomposing the central problem is called. The class object \verb|Variables| is passed to it as a parameter.
This is needed to reach the central problem, the agent pool and thus the amount of all existing agents, and the object of the
off-chain dealer. 
Then, the central problem is decomposed into subproblems which are distributed among the agents. 
The distribution step also includes the distribution of the shared resources. 
Further, the allocation of the shared resources is implemented in such a way that all parties receive equal shares.

\paragraph{Setting of Initial Values:} Furthermore, the off-chain dealer sets the initial values of the resource inventory and the market prices in the dealer's
smart contract. As stated before, the initial resource inventory is calculated in the decomposition step of the central problem. 
We also mentioned earlier in \ref{sec:off_chain_component}, that the market price vector is initialized when instantiating the off-chain dealer class.
The size of the market price vector is equal to the size of the shared resources and is initially specified with zeros.\\

Finally, a few simulation parameters are set, which are needed to determine the termination of the simulation.
These are self-explanatory and not essential for understanding the simulation process, which is why they are not shown in the Listing \ref{lst:initial_setup}.
Afterwards, the simulation loop starts.

\subsubsection{Simulation Loop}
The source code of the simulation loop is outlined in Listing \ref{lst:main_simulation_loop}.
It represents the main process of the simulation and is implemented
by a while loop, which only terminates if the 
market prices from the previous round are equal to the market prices of the current round.
That means, the simulation runs as long as the market prices of the last two rounds differ.

\begin{lstlisting}[float=htbp, label=lst:main_simulation_loop, caption=Main Simulation Loop, language=Python]
    while(not equal_market_prices):
        
        # agent bidding
        for agent in var.agent_pool:
            agent.get_mkt_prices()  # call
            agent.determine_bundle_attributes()
            agent.set_order()  # transact

        utils.wait_for_new_block(var)

        # dealers market matching mechanism
        var.dealer.get_orders()  # call
        var.dealer.create_mmp()
        var.dealer.solve_mmp()
        var.dealer.set_trades()  # transact
        var.dealer.delete_order()  # transact
        var.dealer.set_mkt_prices()  # transact
        var.dealer.set_mmp_attributes()  # transact

        utils.wait_for_new_block(var)

        # agent trade verification
        for agent in var.agent_pool:
            agent.verify_strong_duality()  # call
            agent.accept_trade()  # transact
            agent.add_trade_to_shared_resources()

        utils.wait_for_new_block(var)

        var.dealer.recalculate_resource_inventory() # transact        
\end{lstlisting}

Moreover, the behavior of a blockchain differs from that of conventional client-server architecture.
In the Ethereum blockchain environment, two different method calls are available. 
On the one hand, the \verb|transact()| method, and on the other hand, the \verb|call()| method.
As already stated, the difference lies in the fact that the \verb|transact()| method 
requires the submitting of verified transactions that potentially change the state of the Blockchain, 
whereas the \verb|call()| method only reads the state of the Blockchain. For a \verb|transact()| method 
network verification is needed that causes a significant delay due to the mining procedure.
Consequently, before the values written into the Blockchain by a \verb|transact()| method are accessible, 
a certain time passes. It is important to take this into account when trying to read certain 
values from the Blockchain that are set in previous steps. 
Due to this, we implemented a function called \verb|wait_for_new_block()| that 
reads the current number of blocks out of the Blockchain and waits for the generation of a 
further block. This avoids that state changing transactions are still pending and not anchored 
in a block while they are requested.\\

Further, we divided the simulation loop logically into three thematically summarized actions 
\textit{Agent Bidding}, \textit{Market Matching Mechanism}, and \textit{Agent Trade Verification}.


\paragraph{Agent bidding:}
The \textit{Agent Bidding} represents the technical implementation of section \ref{sec:agent_bidding}.
Figure \ref{figure:agent_bidding_figure} outlines the sequence of all function calls that belong 
to this action.


\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\linewidth]{./figures/agent_bidding.pdf}
	\caption{Sequence of Agent Bidding}
	\label{figure:agent_bidding_figure}
\end{figure}

The agents get the current market prices from the dealer's smart contract, which are required to solve 
the BDP.
To receive the market prices the \verb|call()| method is used and hence proceeds very quickly,
as the values are only read from the blockchain.
Next, the agents solve the BDP based on the received market prices and submit 
the orders and the corresponding prepayment to the dealer's smart contract. In contrast to receiving market prices, 
submitting the orders require the execution of verified transactions that potentially
change the state of the blockchain. Therefore, we make use of the stated 
\verb|wait_for_new_block()| function after the placement of the orders to ensure 
that all submitted orders are take part in the following \textit{Market Matching Mechanism}.


\paragraph{Market Matching Mechanism:}
The \textit{Market Matching Mechanism} represents the technical implementation of section 
\ref{sec:market_clearing_mechanism} and Figure \ref{figure:dealers_mmp} provide 
a sequence of all function calls for this action.

The off-chain dealer waits for the anchoring of the submitted orders and fetches the 
respective bundle orders of the agents. 
As the off-chain dealer only has to read the values of the orders from the blockchain,
fetching the orders is also implemented by a \verb|call()| method, why it proceeds very quickly.
In subject to the received orders, the off-chain dealer creates and solves the MMP.
Since the MMP is solved off-chain, the variety of implementations to solve the MMP is 
not limited. Therefore it is possible to apply commercial solvers for improving 
performance when large problems have to be solved.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\linewidth]{./figures/dealers_mmp.pdf}
	\caption{Sequence of Market Matching Mechanism}
	\label{figure:dealers_mmp}
\end{figure}

After solving the MMP and the calculation of the respective 
trades, the off-chain dealer sets the trades in the dealer's smart contract
and deletes the settled orders out of it.
The newly derived market prices and the values of the MMP and its duals, which are needed 
for the agents trade verification, are set in the dealer's smart contract.
Likewise, the setting of values in the Smart Contract also requires verified 
transactions that have been implemented using the \verb|transact()| method. Since the 
values are required for the agents trade verification, we again utilize the stated 
\verb|wait_for_new_block()| function to ensure the anchoring of the values in the blockchain
before performing the next action.

\paragraph{Agent Trade Verification:}
The \textit{Agent Trade Verification} presents the developed procedure to 
verify the calculated trades of the dealer, which is necessary due to moving
the calculation of the MMP off-chain. A sequence of all function calls contained 
in this action is shown in Figure \ref{figure:agents_trade_verification}.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\linewidth]{./figures/trade_verification.pdf}
	\caption{Sequence of Agents Trade Verification}
	\label{figure:agents_trade_verification}
\end{figure}

The agents verify whether the strong duality theory holds in subject 
to the results of the MMP and the corresponding dual, which are 
fetched from the dealer's smart contract. 
After determining whether the agents accept or reject the trades, the dealer's
smart contract is notified.
In case of acceptance, the dealer's smart contract transfers the refunds 
to the agents and returns the respective trades. Otherwise, in case of  
rejection, the dealer's smart contract transfer the whole prepayment 
and deletes the respective trades.
Finally, the agents add the trades to the shared resources and calculate the new allocation
of the shared resources. Due to the new allocation of 
shared resources, the new objective and wealth level of the agents is calculated.
The invocation of this function only affects if the trade was previously accepted. \newline

At the end of each iteration, the resource inventory of the dealer is recalculated.
Therefore the off-chain dealer calculates how much of the inventory is used for
the trades and settles this with the previous inventory.
Finally, the new calculated inventory is set in the dealer's smart contract.

\clearpage