\section{Implementation}
\label{sec:implementation}

This section deals with the technical implementation of the LEM simulation
and gives insights into the developed source code.
First, a brief introduction to the applied software 
technologies and libraries is given.
Next, the individual components and their attributes and functions are presented. 
Finally, the whole simulation process is outlined and the 
implementation of the fundamental parts 
of the simulation process are described in detail. 

\subsection{Applied technologies}
\label{sec:applied_technologies}
Above all, this subsection give a brief introduction to the used software technologies and libraries.

\paragraph{Python}
An interpreted, object-oriented, high-level programming 
language with dynamic semantics. Additionally, it is simple and 
comes with a easy to learn syntax \footnote{https://www.python.org/}.
The programming language of choice, which is used to develop the 
respective components that communicate via the blockchain.

\paragraph{Web3.py}
A Python library for interacting with a Ethereum blockchain \footnote{https://github.com/ethereum/web3.py}. 
It enables the developed Python components to communicate via the blockchain.

\paragraph{Ganache}
A personal blockchain for Ethereum development \footnote{https://github.com/trufflesuite/ganache-cli}.
It simulates a full client behavior and make developing Ethereum applications faster, easier and safer.
Ganache is provided on the one hand as a software tool with a graphical user interface (GUI) and 
on the other hand as command line tool (CLI). In the develop LEM simulation the command line version 
of Ganache is used. 

\paragraph{Solidity}
A statically typed, contract-oriented, high-level programming language for implementing smart contracts on the Ethereum
blockchain \footnote{https://github.com/ethereum/solidity}.
It is used to implement the smart contract dealer. 

\clearpage
%--------------------------------------
\subsection{Components}
To start off, this subsection presents the respective main components 
that interact with each other during the runtime of the simulation.
However, the individual components are considered in isolation in this subsection.

\subsubsection{Agent}
The agents are implemented by a Python class. Moreover, the naming is oriented on the proposed \textit{BTM} and,
as mentioned earlier in section \ref{sec:concept_of_lem}, the agents represent the respective household 
in the LEM simulation.
To begin with, the class attributes are presented. 
The associated source code can be seen in the following listing \ref{lst:agent_class_attributes}.

\begin{lstlisting}[label=lst:agent_class_attributes, caption=Overview of the agent class attributes, language=Python]
    class Agent(object):

    def __init__(self, agent_number, account_address, web3, dealer_contract):
        self._name = 'AGENT{}'.format(agent_number)
        self._account_address = account_address
        self._web3 = web3
        self._dealer_contract = dealer_contract
        self._optimization_problem = None
        self._bundle_set = None
        self._bid = None
        self._mkt_prices = None
        self._trade = None
        self._objective = None
        self._wealth = None
        self._accept_trade = None
\end{lstlisting}

The variables \verb|agent_number|, \verb|account_address|, \verb|web3| and \verb|dealer_contract| are initialized when the class is instantiated.
The variable \verb|agent_number| is attached to the name of the respective agent and serves as an identifier. 
Otherwise the variable \verb|account_address| could be used to identify the agents, 
but it would be cumbersome due to the cryptic hexadecimal representation of the blockchain account addresses.
Therefore a more understandable name for each agent is established.
Furthermore, each agent is assigned an Ethereum blockchain account defined by the variable \verb|account_address|. It is required to submit and 
receive transactions via the blockchain.
Moreover, the variable \verb|web3| represents the Python library for interacting with a Ethereum blockchain, which is already introduced in section \ref{sec:applied_technologies}.
The last variable which is initialized on instantiation is the \verb|dealer_contract|. 
This variable contains a object of the smart contract dealer. This object knows all implemented functions of the dealer's smart contract.
Hence, this variable is needed to call the functions of the smart contract out of this Python class.
All other class attributes are set immediately after the instantiation or during the running simulation. 

Next, some of the most important functions of the class are introduced and explained.
After the instantiation, each agent get their optimization problem. In the listing \ref{lst:lp_setter} below, the implementation 
of the setter is shown.

\begin{lstlisting}[label=lst:lp_setter, caption=Setter of optimization problem, language=Python]
    @optimization_problem.setter
    def optimization_problem(self, value):
        self._optimization_problem = value
        self._objective = self._optimization_problem.solve().fun
        self._wealth = self.balance + abs(self._objective)
\end{lstlisting}

As you can see in the listing, after setting the optimization problem, the class attributes \verb|objective| and \verb|wealth| will be determined.
In this case, the attribute \verb|wealth| is defined as the sum of the current \verb|balance| of the account and the absolute value of the current \verb|objective|.
Equally, it is defined in the \textit{BTM}, outlined in section \ref{sec:btm}.
However, \verb|balance| is not a class attribute, but a class function. It uses the class attributes \verb|web3| and \verb|account_address| to retrieve the current
balance of the account from the blockchain.

In addtion, the function for determining the improving bundle set and the associated bid is introduced in the listing \ref{lst:determine_bundle}.

\begin{lstlisting}[label=lst:determine_bundle, caption=Determining of bundle attributes, language=Python]
    def determine_bundle_attributes(self):
        result = solve_bundle_determination(self._optimization_problem, self._mkt_prices)
        self._bundle_set = result.x
        self._bid = self._objective - result.fun
\end{lstlisting}

As shown in the listing, first the bundle determination problem will be solved.
It is solved in a separate function depending on the optimization problem and the current market prices.
Due to the high complexity, this function is not shown here. Further, the class attributes \verb|bundle_set| and \verb|bid| are initialized.
We stated in section \ref{sec:agent_bidding} that the applied market mechanism implemented nonstrategic bidding and pricing, wherefore 
an agent will always submit a limit price equal to the valuation of the bundle. 
This is reflected in the definition of the class attribute \verb|bid|. The true value of the improving \verb|bundle_set| 
is the current \verb|objective| minus the objective of the optimization problem with the resources of the \verb|bundle_set|.
In this case, the minus sign reflects the fact that we are minimizing costs.
After presenting the determination of all necessary bundle attributes, the submitment of an order will be shown in the listing \ref{lst:set_order} below.
First of all, the variables \verb|bundle_set| and \verb|bid| will be prepared for sending to the dealer's smart contract.
In Solidity, fixed point numbers are not fully supported yet. It is possible to declare them, but they cannot be assigned to or from \shortcite{solidity_fixed_point}.

\begin{lstlisting}[float=htbp, label=lst:set_order, caption=Submitment of order, language=Python]
    def set_order(self):
        bundle_set = utils.prepare_for_sending(self._bundle_set)
        bid = utils.prepare_for_sending(self._bid)
        
        if(bid > 0):
            prepayment = utils.from_ether_to_wei(self._bid)
        else:
            prepayment = 0

        self._dealer_contract.contract.functions.setOrder(bundle_set, bid, prepayment).transact({'from': self._account_address, 'value': prepayment})
\end{lstlisting}

Therefore, we developed a work around that shift the decimal place two digits to the right and cuts off the remainder,
so that you receive integer values. 

Additionally, the variable \verb|prepayment| is assigned. 
The condition that \verb|bid| is greater than zero identifies if this order represents a buy order.
In case of a buy order, the agents have to pay in advance.
Therefore the value of \verb|prepayment| will be set equally to the value of variable \verb|bid|. 
This procedure is implemented to prevent the strategic placing of orders and to ensure that the financial resources are available.
If it is a sell order, no payment in advance is required and the value of \verb|prepayment| will be set to zero.

Finally, the already introduced class attribute \verb|dealer_contract| is used to call the function of the dealer's smart contract which is
responsible for setting the orders.

Furthermore, the class provide a function to evaluate the published market prices of the dealer. 
This function is implemented to verify if the dealer has calculated the prices of the respective trades 
correctly.  

\begin{lstlisting}[float=htbp, label=lst:verify_trade, caption=Verification of trades, language=Python]
    def verify_strong_duality(self):
        mmp_values, mmp_duals, mmp_target_coefs, mmp_bounds = self.get_mmp_attributes()
        primal_solution = (-np.sum(mmp_values * mmp_target_coefs))
        dual_solution = np.sum(mmp_duals * mmp_bounds)
        primal_solution = math.floor(primal_solution * 10) / 10
        dual_solution = math.floor(dual_solution * 10) / 10

        if primal_solution == dual_solution:
            self._accept_trade = True
        else:
            self._accept_trade = False
\end{lstlisting}

The related source code of this function can be seen in the listing \ref{lst:verify_trade} above. 
To begin with, the function retrieves the values of the primal \textit{market matching problem} and
the belonging dual problem from the dealer's smart contract. For the verification of the correctness, the introduced \textit{Strong Duality Theorem}
in section \ref{sec:strong_duality_theorem} is applied. 
Due to this, it is possible to verify if the solution of the dealer is optimal, without solving the corresponding
\textit{market matching problem}.
To apply the \textit{Strong Duality Theorem}, the solution of the primal problem (represented by variable \verb|primal_solution|) is calculated
on the one hand, and the solution of the dual problem (represented by variable \verb|dual_solution|) on the other hand.
Additionally, both solutions will be rounded to one decimal place. This procedure is implemented due to the issues and limitations of 
floating point arithmetic \footnote{https://docs.python.org/2/tutorial/floatingpoint.html}. 
We want to make sure that correct trades are not rejected on the basis of those limitations.
Finally, it is examined if both solutions are identical. If this is the case, the class variable \verb|accept_trade| of type \verb|boolean| will be
set to \verb|True|, otherwise to \verb|False|.

Likewise, the class provides a function to notify the dealer's smart contract if the respective trade is accepted or not.
The implementation of this function is shown in listing \ref{lst:accept_trade}.

\begin{lstlisting}[float=htbp, label=lst:accept_trade, caption=Notification of trade acceptance, language=Python]
    def accept_trade(self):
        if(self._accept_trade):
            trade = self._dealer_contract.contract.functions.acceptTrade(self._accept_trade).call({'from': self._account_address})
            self._trade = utils.prepare_for_storing(trade)

        self._dealer_contract.contract.functions.acceptTrade(self._accept_trade).transact({'from': self._account_address})

\end{lstlisting}

If the verification of the \textit{Strong Duality Theorem} was successful and the variable \verb|acccept_trade| was thus set to the value \verb|True|,
the function retrieves the trade and stores it in the class attribute \verb|trade|. Besides, before the trade is stored, it will be 
prepared for storing. This is due to the already mentioned work around that shift the decimal place two digits to the right before 
sending values to the dealer's smart contract. When retrieving and storing values, exactly the opposite is done and we shift the decimal place 
two digits to the left. 

Furthermore, as you can see in the listing \ref{lst:accept_trade} above, an almost identical function invocation of the dealer's smart contract 
function \verb|acceptTrade()| is indicated twice. 
The difference lies in the expressions \verb|call()| and \verb|transact()|. 
The \verb|call()| method of the Web3.py library enables to invoke any smart contract function on a read-only basis
and returns values sent by the smart contract return statement. 
Those read-only invocations run much faster than transactions that require network verification.
On the contrary, the \verb|transact()| method submits a verified transaction that potentially change the state 
of the blockchain. 
Hence, network verification is needed that causes a significant delay due to the mining procedure.
Consequently, this method does not return values of the smart contract return statements,
but the transaction hash of the submitted verified transaction.
Regarding the implementation, the first invocation only serves to preserve the respective bundle,
whereas the second call of the function serves to notify the dealer whether the trade has been accepted or not.
For this reason, the first call of the dealer's smart contract 
function \verb|acceptTrade()| is only executed if the trade is accepted. 

Finally, a last class function is described. This function adds the received trade to the shared resources
as it is defined in the \textit{BTM}, introduced in the section \ref{sec:market_clearing_mechanism}.

\begin{lstlisting}[float=htbp, label=lst:add_trade_to_shared_resources, caption=Adding of trade to shared resources, language=Python]
    def add_trade_to_shared_resources(self):
        if(self._accept_trade):
            self._optimization_problem.shared_resources = np.add(self._optimization_problem.shared_resources, self._trade)
            self._objective = self._optimization_problem.solve().fun  
            self._wealth = self.balance + abs(self._objective)
\end{lstlisting}

As shown in the listing \ref{lst:add_trade_to_shared_resources} above, the code of the function 
is only executed if the trade has been accepted. 
In addition, the new \verb|objective| of the linear programming model will be calculated after getting the new resources.
Since a new \verb|objective| has been calculated, the class attribute \verb|wealth| is also recalculated accordingly.



\subsubsection{Smart contract dealer}

In this part, the dealer's smart contract is introduced. 
As already mentioned, the contract is implemented by the programming language Solidity. 
First of all, attributes of the contract are presented in the following listing \ref{lst:contract_attributes}.

\begin{lstlisting}[float=htbp, label=lst:contract_attributes, caption=Attributes of Smart Contract, language=Java]
    contract Dealer{
        // general attributes
        address private _owner;
        int256[] public resource_inventory;
        int256[] public mkt_prices;

        // attributes for order management
        uint32 public order_count;
        uint32[] public order_indices;
        mapping(uint32 => Order) public orders;

        // attributes for trade management
        mapping (address => uint256) account_index; 
        address[] public trades_accounts;
        mapping(address => int256[]) public trades;
        mapping(address => uint256) public bills;
        mapping(address => uint256) public prepayments;
        mapping(address => uint256) public refunds;
\end{lstlisting}

First, general attributes are declared. As you can see, the contract contains an attribute called \verb|owner|.
This variable will be set in the constructor of the contract and initialized with the address of the contract creator,
which is in this case the off-chain dealer.  
It is being used in a modifier which ensures that certain functions can only be executed by the owner of the contract.
Moreover, a modifier can be seen as an extension of a function and is mainly used to 
to check if certain conditions are met before executing the rest of the source code in the body of a function.

In addition, attributes for managing the orders and trades of the agents are declared. 
The orders, trades and additional properties of the trades are predominantly managed in mappings.
A mapping is a collection of key value pairs. All of the keys have to be of the same data type, and 
all values must be of the same data type. However, Solidity does not provide an iteration
function to retrieve all the lists that stored in a mapping. 
That is to say, it is not possible to read the values from the mapping without knowing the respective key.
Therefore, we developed a work around and store the keys of mappings in an additional array which serves 
as a look up table.
With reference to the listing \ref{lst:contract_attributes}, the array \verb|order_indices| functions as a 
look up table for the mapping \verb|orders|, and the array \verb|trades_accounts| for the mapping 
\verb|trades| and all other trades related mappings.

Next, some of the most important functions of the dealer's smart contract are introduced and explained.

To begin with, the function for receiving the agents orders is outlined in the listing \ref{lst:set_order_contract}.
The function header contains on the one hand the built-in modifier \verb|payable|, and on the other hand, the custom
modifier \verb|checkPrepayment|.

\begin{lstlisting}[float=htbp, label=lst:set_order_contract, caption=Receiving agents orders, language=Java]
    function setOrder(int256[] _bundle, uint256 _bid, uint256 _prepayment) public payable checkPrepayment(_prepayment) {

        Order memory new_order = Order(
            msg.sender,
            _bundle,
            _bid
        );
        orders[order_count] = new_order;
        order_indices.push(order_count);

        // increment order count
        order_count ++;
    }
\end{lstlisting}

\begin{comment}
    
\end{comment}


\subsubsection{Off-chain dealer}

\subsubsection{Blockchain}

%--------------------------------------
\subsection{Simulation process}

\subsubsection{Initial setup}

\subsubsection{Agent bidding}

\subsubsection{Dealer's market clearing mechanism}

\subsubsection{Agent trade verification}